!function(c){var r={};function t(g){if(r[g])return r[g].exports;var I=r[g]={i:g,l:!1,exports:{}};return c[g].call(I.exports,I,I.exports,t),I.l=!0,I.exports}t.m=c,t.c=r,t.d=function(c,r,g){t.o(c,r)||Object.defineProperty(c,r,{enumerable:!0,get:g})},t.r=function(c){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(c,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(c,"__esModule",{value:!0})},t.t=function(c,r){if(1&r&&(c=t(c)),8&r)return c;if(4&r&&"object"==typeof c&&c&&c.__esModule)return c;var g=Object.create(null);if(t.r(g),Object.defineProperty(g,"default",{enumerable:!0,value:c}),2&r&&"string"!=typeof c)for(var I in c)t.d(g,I,function(r){return c[r]}.bind(null,I));return g},t.n=function(c){var r=c&&c.__esModule?function(){return c.default}:function(){return c};return t.d(r,"a",r),r},t.o=function(c,r){return Object.prototype.hasOwnProperty.call(c,r)},t.p="",t(t.s=0)}([function(module,exports,__webpack_require__){"use strict";eval('\r\n\r\nif ("serviceWorker" in navigator) {\r\n  window.addEventListener("load", function() {\r\n    navigator.serviceWorker.register("serviceworker.js").then(\r\n      function(registration) {\r\n        // Registration was successful\r\n        console.log(\r\n          "ServiceWorker registration successful with scope: ",\r\n          registration.scope\r\n        );\r\n      },\r\n      function(err) {\r\n        // registration failed\r\n        console.log("ServiceWorker registration failed: ", err);\r\n      }\r\n    );\r\n  });\r\n}\r\n\r\nconsole.log(`Hello Tetromino!`);\r\n\r\nlet canvas;\r\nlet ctx;\r\nlet gameBoardArrayHeight = 20;\r\nlet gameBoardArrayWidth = 12;\r\nlet startX = 0;\r\nlet startY = 0;\r\nlet score = 0;\r\nlet level = 1;\r\nlet winOrLose = "Playing";\r\nlet tetrisLogo;\r\n\r\nlet coordinateArray = [...Array(gameBoardArrayHeight)].map(e =>\r\n  Array(gameBoardArrayWidth).fill(0)\r\n);\r\nconsole.log(coordinateArray);\r\nlet currentTetromino = [\r\n  [1, 0],\r\n  [0, 1],\r\n  [1, 1],\r\n  [2, 1]\r\n];\r\n\r\nlet tetrominos = [];\r\nlet shapesColors = [\r\n  "violet",\r\n  "cyan",\r\n  "blue",\r\n  "green",\r\n  "red",\r\n  "orange",\r\n  "magenta"\r\n];\r\nlet currentTetrominoColor;\r\nlet gameBoardArray = [...Array(20)].map(e => Array(12).fill(0));\r\nlet stoppedShapeArray = [...Array(20)].map(e => Array(12).fill(0));\r\n\r\nlet DIRECTION = {\r\n  IDLE: 0,\r\n  DOWN: 1,\r\n  LEFT: 2,\r\n  RIGHT: 3\r\n};\r\n\r\nlet direction;\r\n\r\nclass Coordinates {\r\n  constructor(x, y) {\r\n    this.x = x;\r\n    this.y = y;\r\n  }\r\n}\r\n\r\nfunction CreateCoordArray() {\r\n  let i = 0,\r\n    j = 0;\r\n  for (let y = 4; y <= 550; y += 22) {\r\n    for (let x = 140; x <= 470; x += 22) {\r\n      coordinateArray[i][j] = new Coordinates(x, y);\r\n      i++;\r\n    }\r\n    j++;\r\n    i = 0;\r\n  }\r\n}\r\n\r\ndocument.addEventListener("DOMContentLoaded", SetupCanvas);\r\n\r\nfunction SetupCanvas() {\r\n  canvas = document.getElementById("canvas");\r\n  ctx = canvas.getContext("2d");\r\n  canvas.width = 640;\r\n  canvas.height = 558;\r\n\r\n  ctx.fillStyle = "white";\r\n  ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n\r\n  ctx.strokeStyle = "black";\r\n  ctx.strokeRect(138, 2, 354, 552);\r\n\r\n  tetrisLogo = new Image(160, 50);\r\n  tetrisLogo.onload = DrawTetrisLogo;\r\n  tetrisLogo.src = "../assets/img/indeks.jpg";\r\n\r\n  ctx.fillStyle = "green";\r\n  ctx.font = "1.3rem Arial";\r\n\r\n  ctx.fillText("Score", 500, 100);\r\n  ctx.fillText(score.toString(), 570, 100);\r\n\r\n  ctx.fillText("Level", 500, 150);\r\n  ctx.fillText(level.toString(), 570, 150);\r\n\r\n  ctx.fillText(winOrLose, 500, 200);\r\n\r\n  ctx.fillText("CONTROLS", 500, 320);\r\n\r\n  ctx.fillText("A: Move left", 500, 350);\r\n  ctx.fillText("D: Move right", 500, 380);\r\n  ctx.fillText("S: Move down", 500, 410);\r\n  ctx.fillText("Space: rotate", 500, 440);\r\n\r\n  document.addEventListener("keydown", handleKeyPress);\r\n\r\n  CreateShapes();\r\n  CreateTetromino();\r\n  CreateCoordArray();\r\n  DrawTetromino();\r\n}\r\n\r\nfunction DrawTetrisLogo() {\r\n  ctx.drawImage(tetrisLogo, 0, 50, 130, 70);\r\n  ctx.drawImage(tetrisLogo, 0, 100, 130, 70);\r\n  ctx.drawImage(tetrisLogo, 0, 150, 130, 70);\r\n  ctx.drawImage(tetrisLogo, 0, 200, 130, 70);\r\n}\r\n\r\nfunction DrawTetromino() {\r\n  for (let i = 0; i < currentTetromino.length; i++) {\r\n    let x = currentTetromino[i][0] + startX;\r\n    let y = currentTetromino[i][1] + startY;\r\n    gameBoardArray[x][y] = 1;\r\n    let coorX = coordinateArray[x][y].x;\r\n    let coorY = coordinateArray[x][y].y;\r\n    ctx.fillStyle = currentTetrominoColor;\r\n    ctx.fillRect(coorX, coorY, 20, 20);\r\n  }\r\n}\r\nfunction DeleteTetromino() {\r\n  for (let i = 0; i < currentTetromino.length; i++) {\r\n    let x = currentTetromino[i][0] + startX;\r\n    let y = currentTetromino[i][1] + startY;\r\n    gameBoardArray[x][y] = 1;\r\n    let coorX = coordinateArray[x][y].x;\r\n    let coorY = coordinateArray[x][y].y;\r\n    ctx.fillStyle = "white";\r\n    ctx.fillRect(coorX, coorY, 20, 20);\r\n  }\r\n}\r\n\r\ndocument.addEventListener("keydown", handleKeyPress);\r\n\r\nfunction handleKeyPress(key) {\r\n  if (key.keyCode === 65) {\r\n    direction = DIRECTION.LEFT;\r\n    if (!HittingTheWall()) {\r\n      MoveLeft();\r\n    }\r\n  } else if (key.keyCode === 68) {\r\n    direction = DIRECTION.RIGHT;\r\n    if (!HittingTheWall()) {\r\n      MoveRight();\r\n    }\r\n  } else if (key.keyCode === 83) {\r\n    direction = DIRECTION.DOWN;\r\n    MoveDown();\r\n  } else if (key.keyCode === 32) {\r\n    RotateTetromino();\r\n  }\r\n}\r\n\r\nfunction MoveLeft() {\r\n  DeleteTetromino();\r\n  startX--;\r\n  DrawTetromino();\r\n}\r\n\r\nfunction MoveRight() {\r\n  direction = DIRECTION.RIGHT;\r\n  DeleteTetromino();\r\n  startX++;\r\n  DrawTetromino();\r\n}\r\n\r\nfunction MoveDown() {\r\n  direction = DIRECTION.DOWN;\r\n  if (!VerticalCollision()) {\r\n    DeleteTetromino();\r\n    startY++;\r\n    DrawTetromino();\r\n  }\r\n}\r\n\r\n// window.setInterval(function() {\r\n//   if (winOrLose != "Game Over") {\r\n//     MoveDown();\r\n//   }\r\n// }, 1000);\r\n\r\nfunction CreateShapes() {\r\n  // T Shape\r\n  tetrominos.push([\r\n    [1, 0],\r\n    [0, 1],\r\n    [1, 1],\r\n    [2, 1]\r\n  ]);\r\n  // I Shape\r\n  tetrominos.push([\r\n    [0, 0],\r\n    [1, 0],\r\n    [2, 0],\r\n    [3, 0]\r\n  ]);\r\n  // J Shape\r\n  tetrominos.push([\r\n    [0, 0],\r\n    [0, 1],\r\n    [1, 1],\r\n    [2, 1]\r\n  ]);\r\n  // Square Shape\r\n  tetrominos.push([\r\n    [0, 0],\r\n    [1, 0],\r\n    [0, 1],\r\n    [1, 1]\r\n  ]);\r\n  // L Shape\r\n  tetrominos.push([\r\n    [2, 0],\r\n    [0, 1],\r\n    [1, 1],\r\n    [2, 1]\r\n  ]);\r\n  // S Shape\r\n  tetrominos.push([\r\n    [1, 0],\r\n    [2, 0],\r\n    [0, 1],\r\n    [1, 1]\r\n  ]);\r\n  // Z Shape\r\n  tetrominos.push([\r\n    [0, 0],\r\n    [1, 0],\r\n    [1, 1],\r\n    [2, 1]\r\n  ]);\r\n}\r\n\r\nfunction CreateTetromino() {\r\n  let randomTetromino = Math.floor(Math.random() * tetrominos.length);\r\n  currentTetromino = tetrominos[randomTetromino];\r\n  currentTetrominoColor = shapesColors[randomTetromino];\r\n}\r\n\r\nfunction HittingTheWall() {\r\n  for (let i = 0; i < currentTetromino.length; i++) {\r\n    let newX = currentTetromino[i][0] + startX;\r\n    if (newX <= 0 && direction === DIRECTION.LEFT) {\r\n      return true;\r\n    } else if (newX >= 15 && direction === DIRECTION.RIGHT) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction VerticalCollision() {\r\n  let copyTetromino = currentTetromino;\r\n  let collision = false;\r\n  for (let i = 0; i < copyTetromino.length; i++) {\r\n    let shape = copyTetromino[i];\r\n    let x = shape[0] + startX;\r\n    let y = shape[1] + startY;\r\n    if (direction === DIRECTION.DOWN) {\r\n      y++;\r\n    }\r\n\r\n    if (typeof stoppedShapeArray[x][y + 1] === "string") {\r\n      DeleteTetromino();\r\n      startY++;\r\n      DrawTetromino();\r\n      collision = true;\r\n      break;\r\n    }\r\n    if (y >= 25) {\r\n      collision = true;\r\n      break;\r\n    }\r\n  }\r\n  if (collision) {\r\n    if (startY <= 2) {\r\n      winOrLose = "Game Over";\r\n      ctx.fillStyle = "red";\r\n      ctx.fillText(winOrLose, 310, 100);\r\n    } else {\r\n      for (let i = 0; i < copyTetromino.length; i++) {\r\n        let shape = copyTetromino[i];\r\n        let x = shape[0] + startX;\r\n        let y = shape[1] + startY;\r\n        stoppedShapeArray[x][y] = currentTetrominoColor;\r\n      }\r\n      CompletedRows();\r\n      CreateTetromino();\r\n      direction = DIRECTION.IDLE;\r\n      startX = 4;\r\n      startY = 0;\r\n      DrawTetromino();\r\n    }\r\n  }\r\n}\r\n\r\nfunction HorizontalCollision() {\r\n  var copyTetromino = currentTetromino;\r\n  var collision = false;\r\n  for (var i = 0; i < copyTetromino.length; i++) {\r\n    var shape = copyTetromino[i];\r\n    var x = shape[0] + startX;\r\n    var y = shape[1] + startY;\r\n\r\n    if (direction === DIRECTION.LEFT) {\r\n      x--;\r\n    } else if (direction === DIRECTION.RIGHT) {\r\n      x++;\r\n    }\r\n    var stoppedShapeValue = stoppedShapeArray[x][y];\r\n    if (typeof stoppedShapeValue === "string") {\r\n      collision = true;\r\n      break;\r\n    }\r\n  }\r\n  return collison;\r\n}\r\n\r\nfunction CompletedRows() {\r\n  // 8. Track how many rows to delete and where to start deleting\r\n  let rowsToDelete = 0;\r\n  let startOfDeletion = 0;\r\n\r\n  // Check every row to see if it has been completed\r\n  for (let y = 0; y < gameBoardArrayHeight; y++) {\r\n    let completed = true;\r\n    // Cycle through x values\r\n    for (let x = 0; x < gameBoardArrayWidth; x++) {\r\n      // Get values stored in the stopped block array\r\n      let square = stoppedShapeArray[x][y];\r\n\r\n      // Check if nothing is there\r\n      if (square === 0 || typeof square === "undefined") {\r\n        // If there is nothing there once then jump out\r\n        // because the row isn\'t completed\r\n        completed = false;\r\n        break;\r\n      }\r\n    }\r\n\r\n    // If a row has been completed\r\n    if (completed) {\r\n      // 8. Used to shift down the rows\r\n      if (startOfDeletion === 0) startOfDeletion = y;\r\n      rowsToDelete++;\r\n\r\n      // Delete the line everywhere\r\n      for (let i = 0; i < gameBoardArrayWidth; i++) {\r\n        // Update the arrays by deleting previous squares\r\n        stoppedShapeArray[i][y] = 0;\r\n        gameBoardArray[i][y] = 0;\r\n        // Look for the x & y values in the lookup table\r\n        let coorX = coordinateArray[i][y].x;\r\n        let coorY = coordinateArray[i][y].y;\r\n        // Draw the square as white\r\n        ctx.fillStyle = "white";\r\n        ctx.fillRect(coorX, coorY, 21, 21);\r\n      }\r\n    }\r\n  }\r\n  if (rowsToDelete > 0) {\r\n    score += 10;\r\n    ctx.fillStyle = "white";\r\n    ctx.fillRect(310, 109, 140, 19);\r\n    ctx.fillStyle = "black";\r\n    ctx.fillText(score.toString(), 310, 127);\r\n    MoveAllRowsDown(rowsToDelete, startOfDeletion);\r\n  }\r\n}\r\n\r\n// function CompletedRows() {\r\n//   let rowsToDelete = 0;\r\n//   let startOfDeletion = 0;\r\n\r\n//   for (let y = 0; y < gameBoardArrayHeight; y++) {\r\n//     let completed = true;\r\n//     for (let x = 0; x < gameBoardArrayWidth; x++) {\r\n//       let shape = stoppedShapeArray[x][y];\r\n//       if (shape === 0 || typeof shape === "undefined") {\r\n//         completed = false;\r\n//         break;\r\n//       }\r\n//     }\r\n//     if (completed) {\r\n//       if (startOfDeletion === 0) startOfDeletion = y;\r\n//       rowsToDelete++;\r\n//       for (let i = 0; i < gameBoardArrayWidth; i++) {\r\n//         stoppedShapeArray[i][y] = 0;\r\n//         gameBoardArray[i][y] = 0;\r\n//         let coorX = coordinateArray[i][y].x;\r\n//         let coorY = coordinateArray[i][y].y;\r\n//         ctx.fillStyle = "white";\r\n//         ctx.fillRect(coorX, coorY, 20, 20);\r\n//       }\r\n//     }\r\n//   }\r\n//   if (rowsToDelete > 0) {\r\n//     score += 10;\r\n//     ctx.fillStyle = "white";\r\n//     ctx.fillRect(310, 110, 140, 20);\r\n//     ctx.fillStyle = "black";\r\n//     ctx.fillText(score.toString(), 310, 130);\r\n//     MoveRowsDown(rowsToDelete, startOfDeletion);\r\n//   }\r\n// }\r\n\r\nfunction MoveAllRowsDown(rowsToDelete, startOfDeletion) {\r\n  for (var i = startOfDeletion - 1; i >= 0; i--) {\r\n    for (var x = 0; x < gameBoardArrayWidth; x++) {\r\n      var y2 = i + rowsToDelete;\r\n      var square = stoppedShapeArray[x][i];\r\n      var nextSquare = stoppedShapeArray[x][y2];\r\n\r\n      if (typeof square === "string") {\r\n        nextSquare = square;\r\n        gameBoardArray[x][y2] = 1; // Put block into GBA\r\n        stoppedShapeArray[x][y2] = square; // Draw color into stopped\r\n\r\n        // Look for the x & y values in the lookup table\r\n        let coorX = coordinateArray[x][y2].x;\r\n        let coorY = coordinateArray[x][y2].y;\r\n        ctx.fillStyle = nextSquare;\r\n        ctx.fillRect(coorX, coorY, 21, 21);\r\n\r\n        square = 0;\r\n        gameBoardArray[x][i] = 0; // Clear the spot in GBA\r\n        stoppedShapeArray[x][i] = 0; // Clear the spot in SSA\r\n        coorX = coordinateArray[x][i].x;\r\n        coorY = coordinateArray[x][i].y;\r\n        ctx.fillStyle = "white";\r\n        ctx.fillRect(coorX, coorY, 21, 21);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// function MoveRowsDown(rowsToDelete, startOfDeletion) {\r\n//   for (var i = startOfDeletion - 1; i >= 0; i--) {\r\n//     for (var x = 0; x < gameBoardArrayWidth; x++) {\r\n//       var y2 = i + rowsToDelete;\r\n//       var shape = stoppedShapeArray[x][i];\r\n//       var nextShape = stoppedShapeArray[x][y2];\r\n//       if (typeof shape === "string") {\r\n//         nextShape = shape;\r\n//         gameBoardArray[x][y2] = 1;\r\n//         stoppedShapeArray[x][y2] = shape;\r\n//         let coorX = coordinateArray[x][y2].x;\r\n//         let coorY = coordinateArray[x][y2].y;\r\n//         ctx.fillStyle = nextSquare;\r\n//         ctx.fillRect(coorX, coorY, 20, 20);\r\n//         shape = 0;\r\n//         gameBoardArray[x][i] = 0;\r\n//         stoppedShapeArray[x][i] = 0;\r\n//         coorX = coordinateArray[x][i].x;\r\n//         coorY = coordinateArray[x][i].y;\r\n//         ctx.fillStyle = "white";\r\n//         ctx.fillRect(coorX, coorY, 20, 20);\r\n//       }\r\n//     }\r\n//   }\r\n// }\r\n\r\nfunction RotateTetromino() {\r\n  let newRotation = new Array();\r\n  let tetrominoCopy = currentTetromino;\r\n  let currentTetrominoBackUp;\r\n  for (let i = 0; i < tetrominoCopy.length; i++) {\r\n    currentTetrominoBackUp = [...currentTetromino];\r\n    let x = tetrominoCopy[i][0];\r\n    let y = tetrominoCopy[i][1];\r\n    let newX = GetLastSquareX() - y;\r\n    let newY = x;\r\n    newRotation.push([newX, newY]);\r\n  }\r\n  DeleteTetromino();\r\n  try {\r\n    currentTetromino = newRotation;\r\n    DrawTetromino();\r\n  } catch (e) {\r\n    if (e instanceof TypeError) {\r\n      currentTetromino = currentTetrominoBackUp;\r\n      DeleteTetromino();\r\n      DrawTetromino();\r\n    }\r\n  }\r\n}\r\nfunction GetLastSquareX() {\r\n  let lastX = 0;\r\n  for (let i = 0; i < currentTetromino.length; i++) {\r\n    let square = currentTetromino[i];\r\n    if (square[0] > lastX) lastX = square[0];\r\n  }\r\n  return lastX;\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvbWFpbi5qcz85MjkxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0IscUJBQXFCLFVBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLDZCQUE2QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw2QkFBNkI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQiw2QkFBNkI7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDBCQUEwQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxxQkFBcUIsMEJBQTBCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDBCQUEwQjtBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQiwwQkFBMEI7QUFDM0M7QUFDQTtBQUNBLG1CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIseUJBQXlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBLHNCQUFzQix5QkFBeUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQyxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQztBQUNqQyxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDLHNCQUFzQix5QkFBeUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMEJBQTBCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDZCQUE2QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmlmIChcInNlcnZpY2VXb3JrZXJcIiBpbiBuYXZpZ2F0b3IpIHtcclxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgZnVuY3Rpb24oKSB7XHJcbiAgICBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5yZWdpc3RlcihcInNlcnZpY2V3b3JrZXIuanNcIikudGhlbihcclxuICAgICAgZnVuY3Rpb24ocmVnaXN0cmF0aW9uKSB7XHJcbiAgICAgICAgLy8gUmVnaXN0cmF0aW9uIHdhcyBzdWNjZXNzZnVsXHJcbiAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICBcIlNlcnZpY2VXb3JrZXIgcmVnaXN0cmF0aW9uIHN1Y2Nlc3NmdWwgd2l0aCBzY29wZTogXCIsXHJcbiAgICAgICAgICByZWdpc3RyYXRpb24uc2NvcGVcclxuICAgICAgICApO1xyXG4gICAgICB9LFxyXG4gICAgICBmdW5jdGlvbihlcnIpIHtcclxuICAgICAgICAvLyByZWdpc3RyYXRpb24gZmFpbGVkXHJcbiAgICAgICAgY29uc29sZS5sb2coXCJTZXJ2aWNlV29ya2VyIHJlZ2lzdHJhdGlvbiBmYWlsZWQ6IFwiLCBlcnIpO1xyXG4gICAgICB9XHJcbiAgICApO1xyXG4gIH0pO1xyXG59XHJcblxyXG5jb25zb2xlLmxvZyhgSGVsbG8gVGV0cm9taW5vIWApO1xyXG5cclxubGV0IGNhbnZhcztcclxubGV0IGN0eDtcclxubGV0IGdhbWVCb2FyZEFycmF5SGVpZ2h0ID0gMjA7XHJcbmxldCBnYW1lQm9hcmRBcnJheVdpZHRoID0gMTI7XHJcbmxldCBzdGFydFggPSAwO1xyXG5sZXQgc3RhcnRZID0gMDtcclxubGV0IHNjb3JlID0gMDtcclxubGV0IGxldmVsID0gMTtcclxubGV0IHdpbk9yTG9zZSA9IFwiUGxheWluZ1wiO1xyXG5sZXQgdGV0cmlzTG9nbztcclxuXHJcbmxldCBjb29yZGluYXRlQXJyYXkgPSBbLi4uQXJyYXkoZ2FtZUJvYXJkQXJyYXlIZWlnaHQpXS5tYXAoZSA9PlxyXG4gIEFycmF5KGdhbWVCb2FyZEFycmF5V2lkdGgpLmZpbGwoMClcclxuKTtcclxuY29uc29sZS5sb2coY29vcmRpbmF0ZUFycmF5KTtcclxubGV0IGN1cnJlbnRUZXRyb21pbm8gPSBbXHJcbiAgWzEsIDBdLFxyXG4gIFswLCAxXSxcclxuICBbMSwgMV0sXHJcbiAgWzIsIDFdXHJcbl07XHJcblxyXG5sZXQgdGV0cm9taW5vcyA9IFtdO1xyXG5sZXQgc2hhcGVzQ29sb3JzID0gW1xyXG4gIFwidmlvbGV0XCIsXHJcbiAgXCJjeWFuXCIsXHJcbiAgXCJibHVlXCIsXHJcbiAgXCJncmVlblwiLFxyXG4gIFwicmVkXCIsXHJcbiAgXCJvcmFuZ2VcIixcclxuICBcIm1hZ2VudGFcIlxyXG5dO1xyXG5sZXQgY3VycmVudFRldHJvbWlub0NvbG9yO1xyXG5sZXQgZ2FtZUJvYXJkQXJyYXkgPSBbLi4uQXJyYXkoMjApXS5tYXAoZSA9PiBBcnJheSgxMikuZmlsbCgwKSk7XHJcbmxldCBzdG9wcGVkU2hhcGVBcnJheSA9IFsuLi5BcnJheSgyMCldLm1hcChlID0+IEFycmF5KDEyKS5maWxsKDApKTtcclxuXHJcbmxldCBESVJFQ1RJT04gPSB7XHJcbiAgSURMRTogMCxcclxuICBET1dOOiAxLFxyXG4gIExFRlQ6IDIsXHJcbiAgUklHSFQ6IDNcclxufTtcclxuXHJcbmxldCBkaXJlY3Rpb247XHJcblxyXG5jbGFzcyBDb29yZGluYXRlcyB7XHJcbiAgY29uc3RydWN0b3IoeCwgeSkge1xyXG4gICAgdGhpcy54ID0geDtcclxuICAgIHRoaXMueSA9IHk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBDcmVhdGVDb29yZEFycmF5KCkge1xyXG4gIGxldCBpID0gMCxcclxuICAgIGogPSAwO1xyXG4gIGZvciAobGV0IHkgPSA0OyB5IDw9IDU1MDsgeSArPSAyMikge1xyXG4gICAgZm9yIChsZXQgeCA9IDE0MDsgeCA8PSA0NzA7IHggKz0gMjIpIHtcclxuICAgICAgY29vcmRpbmF0ZUFycmF5W2ldW2pdID0gbmV3IENvb3JkaW5hdGVzKHgsIHkpO1xyXG4gICAgICBpKys7XHJcbiAgICB9XHJcbiAgICBqKys7XHJcbiAgICBpID0gMDtcclxuICB9XHJcbn1cclxuXHJcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIFNldHVwQ2FudmFzKTtcclxuXHJcbmZ1bmN0aW9uIFNldHVwQ2FudmFzKCkge1xyXG4gIGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY2FudmFzXCIpO1xyXG4gIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcbiAgY2FudmFzLndpZHRoID0gNjQwO1xyXG4gIGNhbnZhcy5oZWlnaHQgPSA1NTg7XHJcblxyXG4gIGN0eC5maWxsU3R5bGUgPSBcIndoaXRlXCI7XHJcbiAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcblxyXG4gIGN0eC5zdHJva2VTdHlsZSA9IFwiYmxhY2tcIjtcclxuICBjdHguc3Ryb2tlUmVjdCgxMzgsIDIsIDM1NCwgNTUyKTtcclxuXHJcbiAgdGV0cmlzTG9nbyA9IG5ldyBJbWFnZSgxNjAsIDUwKTtcclxuICB0ZXRyaXNMb2dvLm9ubG9hZCA9IERyYXdUZXRyaXNMb2dvO1xyXG4gIHRldHJpc0xvZ28uc3JjID0gXCIuLi9hc3NldHMvaW1nL2luZGVrcy5qcGdcIjtcclxuXHJcbiAgY3R4LmZpbGxTdHlsZSA9IFwiZ3JlZW5cIjtcclxuICBjdHguZm9udCA9IFwiMS4zcmVtIEFyaWFsXCI7XHJcblxyXG4gIGN0eC5maWxsVGV4dChcIlNjb3JlXCIsIDUwMCwgMTAwKTtcclxuICBjdHguZmlsbFRleHQoc2NvcmUudG9TdHJpbmcoKSwgNTcwLCAxMDApO1xyXG5cclxuICBjdHguZmlsbFRleHQoXCJMZXZlbFwiLCA1MDAsIDE1MCk7XHJcbiAgY3R4LmZpbGxUZXh0KGxldmVsLnRvU3RyaW5nKCksIDU3MCwgMTUwKTtcclxuXHJcbiAgY3R4LmZpbGxUZXh0KHdpbk9yTG9zZSwgNTAwLCAyMDApO1xyXG5cclxuICBjdHguZmlsbFRleHQoXCJDT05UUk9MU1wiLCA1MDAsIDMyMCk7XHJcblxyXG4gIGN0eC5maWxsVGV4dChcIkE6IE1vdmUgbGVmdFwiLCA1MDAsIDM1MCk7XHJcbiAgY3R4LmZpbGxUZXh0KFwiRDogTW92ZSByaWdodFwiLCA1MDAsIDM4MCk7XHJcbiAgY3R4LmZpbGxUZXh0KFwiUzogTW92ZSBkb3duXCIsIDUwMCwgNDEwKTtcclxuICBjdHguZmlsbFRleHQoXCJTcGFjZTogcm90YXRlXCIsIDUwMCwgNDQwKTtcclxuXHJcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgaGFuZGxlS2V5UHJlc3MpO1xyXG5cclxuICBDcmVhdGVTaGFwZXMoKTtcclxuICBDcmVhdGVUZXRyb21pbm8oKTtcclxuICBDcmVhdGVDb29yZEFycmF5KCk7XHJcbiAgRHJhd1RldHJvbWlubygpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBEcmF3VGV0cmlzTG9nbygpIHtcclxuICBjdHguZHJhd0ltYWdlKHRldHJpc0xvZ28sIDAsIDUwLCAxMzAsIDcwKTtcclxuICBjdHguZHJhd0ltYWdlKHRldHJpc0xvZ28sIDAsIDEwMCwgMTMwLCA3MCk7XHJcbiAgY3R4LmRyYXdJbWFnZSh0ZXRyaXNMb2dvLCAwLCAxNTAsIDEzMCwgNzApO1xyXG4gIGN0eC5kcmF3SW1hZ2UodGV0cmlzTG9nbywgMCwgMjAwLCAxMzAsIDcwKTtcclxufVxyXG5cclxuZnVuY3Rpb24gRHJhd1RldHJvbWlubygpIHtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbnRUZXRyb21pbm8ubGVuZ3RoOyBpKyspIHtcclxuICAgIGxldCB4ID0gY3VycmVudFRldHJvbWlub1tpXVswXSArIHN0YXJ0WDtcclxuICAgIGxldCB5ID0gY3VycmVudFRldHJvbWlub1tpXVsxXSArIHN0YXJ0WTtcclxuICAgIGdhbWVCb2FyZEFycmF5W3hdW3ldID0gMTtcclxuICAgIGxldCBjb29yWCA9IGNvb3JkaW5hdGVBcnJheVt4XVt5XS54O1xyXG4gICAgbGV0IGNvb3JZID0gY29vcmRpbmF0ZUFycmF5W3hdW3ldLnk7XHJcbiAgICBjdHguZmlsbFN0eWxlID0gY3VycmVudFRldHJvbWlub0NvbG9yO1xyXG4gICAgY3R4LmZpbGxSZWN0KGNvb3JYLCBjb29yWSwgMjAsIDIwKTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gRGVsZXRlVGV0cm9taW5vKCkge1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVudFRldHJvbWluby5sZW5ndGg7IGkrKykge1xyXG4gICAgbGV0IHggPSBjdXJyZW50VGV0cm9taW5vW2ldWzBdICsgc3RhcnRYO1xyXG4gICAgbGV0IHkgPSBjdXJyZW50VGV0cm9taW5vW2ldWzFdICsgc3RhcnRZO1xyXG4gICAgZ2FtZUJvYXJkQXJyYXlbeF1beV0gPSAxO1xyXG4gICAgbGV0IGNvb3JYID0gY29vcmRpbmF0ZUFycmF5W3hdW3ldLng7XHJcbiAgICBsZXQgY29vclkgPSBjb29yZGluYXRlQXJyYXlbeF1beV0ueTtcclxuICAgIGN0eC5maWxsU3R5bGUgPSBcIndoaXRlXCI7XHJcbiAgICBjdHguZmlsbFJlY3QoY29vclgsIGNvb3JZLCAyMCwgMjApO1xyXG4gIH1cclxufVxyXG5cclxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgaGFuZGxlS2V5UHJlc3MpO1xyXG5cclxuZnVuY3Rpb24gaGFuZGxlS2V5UHJlc3Moa2V5KSB7XHJcbiAgaWYgKGtleS5rZXlDb2RlID09PSA2NSkge1xyXG4gICAgZGlyZWN0aW9uID0gRElSRUNUSU9OLkxFRlQ7XHJcbiAgICBpZiAoIUhpdHRpbmdUaGVXYWxsKCkpIHtcclxuICAgICAgTW92ZUxlZnQoKTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKGtleS5rZXlDb2RlID09PSA2OCkge1xyXG4gICAgZGlyZWN0aW9uID0gRElSRUNUSU9OLlJJR0hUO1xyXG4gICAgaWYgKCFIaXR0aW5nVGhlV2FsbCgpKSB7XHJcbiAgICAgIE1vdmVSaWdodCgpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoa2V5LmtleUNvZGUgPT09IDgzKSB7XHJcbiAgICBkaXJlY3Rpb24gPSBESVJFQ1RJT04uRE9XTjtcclxuICAgIE1vdmVEb3duKCk7XHJcbiAgfSBlbHNlIGlmIChrZXkua2V5Q29kZSA9PT0gMzIpIHtcclxuICAgIFJvdGF0ZVRldHJvbWlubygpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gTW92ZUxlZnQoKSB7XHJcbiAgRGVsZXRlVGV0cm9taW5vKCk7XHJcbiAgc3RhcnRYLS07XHJcbiAgRHJhd1RldHJvbWlubygpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBNb3ZlUmlnaHQoKSB7XHJcbiAgZGlyZWN0aW9uID0gRElSRUNUSU9OLlJJR0hUO1xyXG4gIERlbGV0ZVRldHJvbWlubygpO1xyXG4gIHN0YXJ0WCsrO1xyXG4gIERyYXdUZXRyb21pbm8oKTtcclxufVxyXG5cclxuZnVuY3Rpb24gTW92ZURvd24oKSB7XHJcbiAgZGlyZWN0aW9uID0gRElSRUNUSU9OLkRPV047XHJcbiAgaWYgKCFWZXJ0aWNhbENvbGxpc2lvbigpKSB7XHJcbiAgICBEZWxldGVUZXRyb21pbm8oKTtcclxuICAgIHN0YXJ0WSsrO1xyXG4gICAgRHJhd1RldHJvbWlubygpO1xyXG4gIH1cclxufVxyXG5cclxuLy8gd2luZG93LnNldEludGVydmFsKGZ1bmN0aW9uKCkge1xyXG4vLyAgIGlmICh3aW5Pckxvc2UgIT0gXCJHYW1lIE92ZXJcIikge1xyXG4vLyAgICAgTW92ZURvd24oKTtcclxuLy8gICB9XHJcbi8vIH0sIDEwMDApO1xyXG5cclxuZnVuY3Rpb24gQ3JlYXRlU2hhcGVzKCkge1xyXG4gIC8vIFQgU2hhcGVcclxuICB0ZXRyb21pbm9zLnB1c2goW1xyXG4gICAgWzEsIDBdLFxyXG4gICAgWzAsIDFdLFxyXG4gICAgWzEsIDFdLFxyXG4gICAgWzIsIDFdXHJcbiAgXSk7XHJcbiAgLy8gSSBTaGFwZVxyXG4gIHRldHJvbWlub3MucHVzaChbXHJcbiAgICBbMCwgMF0sXHJcbiAgICBbMSwgMF0sXHJcbiAgICBbMiwgMF0sXHJcbiAgICBbMywgMF1cclxuICBdKTtcclxuICAvLyBKIFNoYXBlXHJcbiAgdGV0cm9taW5vcy5wdXNoKFtcclxuICAgIFswLCAwXSxcclxuICAgIFswLCAxXSxcclxuICAgIFsxLCAxXSxcclxuICAgIFsyLCAxXVxyXG4gIF0pO1xyXG4gIC8vIFNxdWFyZSBTaGFwZVxyXG4gIHRldHJvbWlub3MucHVzaChbXHJcbiAgICBbMCwgMF0sXHJcbiAgICBbMSwgMF0sXHJcbiAgICBbMCwgMV0sXHJcbiAgICBbMSwgMV1cclxuICBdKTtcclxuICAvLyBMIFNoYXBlXHJcbiAgdGV0cm9taW5vcy5wdXNoKFtcclxuICAgIFsyLCAwXSxcclxuICAgIFswLCAxXSxcclxuICAgIFsxLCAxXSxcclxuICAgIFsyLCAxXVxyXG4gIF0pO1xyXG4gIC8vIFMgU2hhcGVcclxuICB0ZXRyb21pbm9zLnB1c2goW1xyXG4gICAgWzEsIDBdLFxyXG4gICAgWzIsIDBdLFxyXG4gICAgWzAsIDFdLFxyXG4gICAgWzEsIDFdXHJcbiAgXSk7XHJcbiAgLy8gWiBTaGFwZVxyXG4gIHRldHJvbWlub3MucHVzaChbXHJcbiAgICBbMCwgMF0sXHJcbiAgICBbMSwgMF0sXHJcbiAgICBbMSwgMV0sXHJcbiAgICBbMiwgMV1cclxuICBdKTtcclxufVxyXG5cclxuZnVuY3Rpb24gQ3JlYXRlVGV0cm9taW5vKCkge1xyXG4gIGxldCByYW5kb21UZXRyb21pbm8gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB0ZXRyb21pbm9zLmxlbmd0aCk7XHJcbiAgY3VycmVudFRldHJvbWlubyA9IHRldHJvbWlub3NbcmFuZG9tVGV0cm9taW5vXTtcclxuICBjdXJyZW50VGV0cm9taW5vQ29sb3IgPSBzaGFwZXNDb2xvcnNbcmFuZG9tVGV0cm9taW5vXTtcclxufVxyXG5cclxuZnVuY3Rpb24gSGl0dGluZ1RoZVdhbGwoKSB7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW50VGV0cm9taW5vLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBsZXQgbmV3WCA9IGN1cnJlbnRUZXRyb21pbm9baV1bMF0gKyBzdGFydFg7XHJcbiAgICBpZiAobmV3WCA8PSAwICYmIGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OLkxFRlQpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9IGVsc2UgaWYgKG5ld1ggPj0gMTUgJiYgZGlyZWN0aW9uID09PSBESVJFQ1RJT04uUklHSFQpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBmYWxzZTtcclxufVxyXG5cclxuZnVuY3Rpb24gVmVydGljYWxDb2xsaXNpb24oKSB7XHJcbiAgbGV0IGNvcHlUZXRyb21pbm8gPSBjdXJyZW50VGV0cm9taW5vO1xyXG4gIGxldCBjb2xsaXNpb24gPSBmYWxzZTtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvcHlUZXRyb21pbm8ubGVuZ3RoOyBpKyspIHtcclxuICAgIGxldCBzaGFwZSA9IGNvcHlUZXRyb21pbm9baV07XHJcbiAgICBsZXQgeCA9IHNoYXBlWzBdICsgc3RhcnRYO1xyXG4gICAgbGV0IHkgPSBzaGFwZVsxXSArIHN0YXJ0WTtcclxuICAgIGlmIChkaXJlY3Rpb24gPT09IERJUkVDVElPTi5ET1dOKSB7XHJcbiAgICAgIHkrKztcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIHN0b3BwZWRTaGFwZUFycmF5W3hdW3kgKyAxXSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICBEZWxldGVUZXRyb21pbm8oKTtcclxuICAgICAgc3RhcnRZKys7XHJcbiAgICAgIERyYXdUZXRyb21pbm8oKTtcclxuICAgICAgY29sbGlzaW9uID0gdHJ1ZTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICBpZiAoeSA+PSAyNSkge1xyXG4gICAgICBjb2xsaXNpb24gPSB0cnVlO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcbiAgaWYgKGNvbGxpc2lvbikge1xyXG4gICAgaWYgKHN0YXJ0WSA8PSAyKSB7XHJcbiAgICAgIHdpbk9yTG9zZSA9IFwiR2FtZSBPdmVyXCI7XHJcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBcInJlZFwiO1xyXG4gICAgICBjdHguZmlsbFRleHQod2luT3JMb3NlLCAzMTAsIDEwMCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvcHlUZXRyb21pbm8ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgc2hhcGUgPSBjb3B5VGV0cm9taW5vW2ldO1xyXG4gICAgICAgIGxldCB4ID0gc2hhcGVbMF0gKyBzdGFydFg7XHJcbiAgICAgICAgbGV0IHkgPSBzaGFwZVsxXSArIHN0YXJ0WTtcclxuICAgICAgICBzdG9wcGVkU2hhcGVBcnJheVt4XVt5XSA9IGN1cnJlbnRUZXRyb21pbm9Db2xvcjtcclxuICAgICAgfVxyXG4gICAgICBDb21wbGV0ZWRSb3dzKCk7XHJcbiAgICAgIENyZWF0ZVRldHJvbWlubygpO1xyXG4gICAgICBkaXJlY3Rpb24gPSBESVJFQ1RJT04uSURMRTtcclxuICAgICAgc3RhcnRYID0gNDtcclxuICAgICAgc3RhcnRZID0gMDtcclxuICAgICAgRHJhd1RldHJvbWlubygpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gSG9yaXpvbnRhbENvbGxpc2lvbigpIHtcclxuICB2YXIgY29weVRldHJvbWlubyA9IGN1cnJlbnRUZXRyb21pbm87XHJcbiAgdmFyIGNvbGxpc2lvbiA9IGZhbHNlO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29weVRldHJvbWluby5sZW5ndGg7IGkrKykge1xyXG4gICAgdmFyIHNoYXBlID0gY29weVRldHJvbWlub1tpXTtcclxuICAgIHZhciB4ID0gc2hhcGVbMF0gKyBzdGFydFg7XHJcbiAgICB2YXIgeSA9IHNoYXBlWzFdICsgc3RhcnRZO1xyXG5cclxuICAgIGlmIChkaXJlY3Rpb24gPT09IERJUkVDVElPTi5MRUZUKSB7XHJcbiAgICAgIHgtLTtcclxuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSBESVJFQ1RJT04uUklHSFQpIHtcclxuICAgICAgeCsrO1xyXG4gICAgfVxyXG4gICAgdmFyIHN0b3BwZWRTaGFwZVZhbHVlID0gc3RvcHBlZFNoYXBlQXJyYXlbeF1beV07XHJcbiAgICBpZiAodHlwZW9mIHN0b3BwZWRTaGFwZVZhbHVlID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgIGNvbGxpc2lvbiA9IHRydWU7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gY29sbGlzb247XHJcbn1cclxuXHJcbmZ1bmN0aW9uIENvbXBsZXRlZFJvd3MoKSB7XHJcbiAgLy8gOC4gVHJhY2sgaG93IG1hbnkgcm93cyB0byBkZWxldGUgYW5kIHdoZXJlIHRvIHN0YXJ0IGRlbGV0aW5nXHJcbiAgbGV0IHJvd3NUb0RlbGV0ZSA9IDA7XHJcbiAgbGV0IHN0YXJ0T2ZEZWxldGlvbiA9IDA7XHJcblxyXG4gIC8vIENoZWNrIGV2ZXJ5IHJvdyB0byBzZWUgaWYgaXQgaGFzIGJlZW4gY29tcGxldGVkXHJcbiAgZm9yIChsZXQgeSA9IDA7IHkgPCBnYW1lQm9hcmRBcnJheUhlaWdodDsgeSsrKSB7XHJcbiAgICBsZXQgY29tcGxldGVkID0gdHJ1ZTtcclxuICAgIC8vIEN5Y2xlIHRocm91Z2ggeCB2YWx1ZXNcclxuICAgIGZvciAobGV0IHggPSAwOyB4IDwgZ2FtZUJvYXJkQXJyYXlXaWR0aDsgeCsrKSB7XHJcbiAgICAgIC8vIEdldCB2YWx1ZXMgc3RvcmVkIGluIHRoZSBzdG9wcGVkIGJsb2NrIGFycmF5XHJcbiAgICAgIGxldCBzcXVhcmUgPSBzdG9wcGVkU2hhcGVBcnJheVt4XVt5XTtcclxuXHJcbiAgICAgIC8vIENoZWNrIGlmIG5vdGhpbmcgaXMgdGhlcmVcclxuICAgICAgaWYgKHNxdWFyZSA9PT0gMCB8fCB0eXBlb2Ygc3F1YXJlID09PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm90aGluZyB0aGVyZSBvbmNlIHRoZW4ganVtcCBvdXRcclxuICAgICAgICAvLyBiZWNhdXNlIHRoZSByb3cgaXNuJ3QgY29tcGxldGVkXHJcbiAgICAgICAgY29tcGxldGVkID0gZmFsc2U7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBJZiBhIHJvdyBoYXMgYmVlbiBjb21wbGV0ZWRcclxuICAgIGlmIChjb21wbGV0ZWQpIHtcclxuICAgICAgLy8gOC4gVXNlZCB0byBzaGlmdCBkb3duIHRoZSByb3dzXHJcbiAgICAgIGlmIChzdGFydE9mRGVsZXRpb24gPT09IDApIHN0YXJ0T2ZEZWxldGlvbiA9IHk7XHJcbiAgICAgIHJvd3NUb0RlbGV0ZSsrO1xyXG5cclxuICAgICAgLy8gRGVsZXRlIHRoZSBsaW5lIGV2ZXJ5d2hlcmVcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnYW1lQm9hcmRBcnJheVdpZHRoOyBpKyspIHtcclxuICAgICAgICAvLyBVcGRhdGUgdGhlIGFycmF5cyBieSBkZWxldGluZyBwcmV2aW91cyBzcXVhcmVzXHJcbiAgICAgICAgc3RvcHBlZFNoYXBlQXJyYXlbaV1beV0gPSAwO1xyXG4gICAgICAgIGdhbWVCb2FyZEFycmF5W2ldW3ldID0gMDtcclxuICAgICAgICAvLyBMb29rIGZvciB0aGUgeCAmIHkgdmFsdWVzIGluIHRoZSBsb29rdXAgdGFibGVcclxuICAgICAgICBsZXQgY29vclggPSBjb29yZGluYXRlQXJyYXlbaV1beV0ueDtcclxuICAgICAgICBsZXQgY29vclkgPSBjb29yZGluYXRlQXJyYXlbaV1beV0ueTtcclxuICAgICAgICAvLyBEcmF3IHRoZSBzcXVhcmUgYXMgd2hpdGVcclxuICAgICAgICBjdHguZmlsbFN0eWxlID0gXCJ3aGl0ZVwiO1xyXG4gICAgICAgIGN0eC5maWxsUmVjdChjb29yWCwgY29vclksIDIxLCAyMSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgaWYgKHJvd3NUb0RlbGV0ZSA+IDApIHtcclxuICAgIHNjb3JlICs9IDEwO1xyXG4gICAgY3R4LmZpbGxTdHlsZSA9IFwid2hpdGVcIjtcclxuICAgIGN0eC5maWxsUmVjdCgzMTAsIDEwOSwgMTQwLCAxOSk7XHJcbiAgICBjdHguZmlsbFN0eWxlID0gXCJibGFja1wiO1xyXG4gICAgY3R4LmZpbGxUZXh0KHNjb3JlLnRvU3RyaW5nKCksIDMxMCwgMTI3KTtcclxuICAgIE1vdmVBbGxSb3dzRG93bihyb3dzVG9EZWxldGUsIHN0YXJ0T2ZEZWxldGlvbik7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBmdW5jdGlvbiBDb21wbGV0ZWRSb3dzKCkge1xyXG4vLyAgIGxldCByb3dzVG9EZWxldGUgPSAwO1xyXG4vLyAgIGxldCBzdGFydE9mRGVsZXRpb24gPSAwO1xyXG5cclxuLy8gICBmb3IgKGxldCB5ID0gMDsgeSA8IGdhbWVCb2FyZEFycmF5SGVpZ2h0OyB5KyspIHtcclxuLy8gICAgIGxldCBjb21wbGV0ZWQgPSB0cnVlO1xyXG4vLyAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBnYW1lQm9hcmRBcnJheVdpZHRoOyB4KyspIHtcclxuLy8gICAgICAgbGV0IHNoYXBlID0gc3RvcHBlZFNoYXBlQXJyYXlbeF1beV07XHJcbi8vICAgICAgIGlmIChzaGFwZSA9PT0gMCB8fCB0eXBlb2Ygc2hhcGUgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuLy8gICAgICAgICBjb21wbGV0ZWQgPSBmYWxzZTtcclxuLy8gICAgICAgICBicmVhaztcclxuLy8gICAgICAgfVxyXG4vLyAgICAgfVxyXG4vLyAgICAgaWYgKGNvbXBsZXRlZCkge1xyXG4vLyAgICAgICBpZiAoc3RhcnRPZkRlbGV0aW9uID09PSAwKSBzdGFydE9mRGVsZXRpb24gPSB5O1xyXG4vLyAgICAgICByb3dzVG9EZWxldGUrKztcclxuLy8gICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnYW1lQm9hcmRBcnJheVdpZHRoOyBpKyspIHtcclxuLy8gICAgICAgICBzdG9wcGVkU2hhcGVBcnJheVtpXVt5XSA9IDA7XHJcbi8vICAgICAgICAgZ2FtZUJvYXJkQXJyYXlbaV1beV0gPSAwO1xyXG4vLyAgICAgICAgIGxldCBjb29yWCA9IGNvb3JkaW5hdGVBcnJheVtpXVt5XS54O1xyXG4vLyAgICAgICAgIGxldCBjb29yWSA9IGNvb3JkaW5hdGVBcnJheVtpXVt5XS55O1xyXG4vLyAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIndoaXRlXCI7XHJcbi8vICAgICAgICAgY3R4LmZpbGxSZWN0KGNvb3JYLCBjb29yWSwgMjAsIDIwKTtcclxuLy8gICAgICAgfVxyXG4vLyAgICAgfVxyXG4vLyAgIH1cclxuLy8gICBpZiAocm93c1RvRGVsZXRlID4gMCkge1xyXG4vLyAgICAgc2NvcmUgKz0gMTA7XHJcbi8vICAgICBjdHguZmlsbFN0eWxlID0gXCJ3aGl0ZVwiO1xyXG4vLyAgICAgY3R4LmZpbGxSZWN0KDMxMCwgMTEwLCAxNDAsIDIwKTtcclxuLy8gICAgIGN0eC5maWxsU3R5bGUgPSBcImJsYWNrXCI7XHJcbi8vICAgICBjdHguZmlsbFRleHQoc2NvcmUudG9TdHJpbmcoKSwgMzEwLCAxMzApO1xyXG4vLyAgICAgTW92ZVJvd3NEb3duKHJvd3NUb0RlbGV0ZSwgc3RhcnRPZkRlbGV0aW9uKTtcclxuLy8gICB9XHJcbi8vIH1cclxuXHJcbmZ1bmN0aW9uIE1vdmVBbGxSb3dzRG93bihyb3dzVG9EZWxldGUsIHN0YXJ0T2ZEZWxldGlvbikge1xyXG4gIGZvciAodmFyIGkgPSBzdGFydE9mRGVsZXRpb24gLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgZm9yICh2YXIgeCA9IDA7IHggPCBnYW1lQm9hcmRBcnJheVdpZHRoOyB4KyspIHtcclxuICAgICAgdmFyIHkyID0gaSArIHJvd3NUb0RlbGV0ZTtcclxuICAgICAgdmFyIHNxdWFyZSA9IHN0b3BwZWRTaGFwZUFycmF5W3hdW2ldO1xyXG4gICAgICB2YXIgbmV4dFNxdWFyZSA9IHN0b3BwZWRTaGFwZUFycmF5W3hdW3kyXTtcclxuXHJcbiAgICAgIGlmICh0eXBlb2Ygc3F1YXJlID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgbmV4dFNxdWFyZSA9IHNxdWFyZTtcclxuICAgICAgICBnYW1lQm9hcmRBcnJheVt4XVt5Ml0gPSAxOyAvLyBQdXQgYmxvY2sgaW50byBHQkFcclxuICAgICAgICBzdG9wcGVkU2hhcGVBcnJheVt4XVt5Ml0gPSBzcXVhcmU7IC8vIERyYXcgY29sb3IgaW50byBzdG9wcGVkXHJcblxyXG4gICAgICAgIC8vIExvb2sgZm9yIHRoZSB4ICYgeSB2YWx1ZXMgaW4gdGhlIGxvb2t1cCB0YWJsZVxyXG4gICAgICAgIGxldCBjb29yWCA9IGNvb3JkaW5hdGVBcnJheVt4XVt5Ml0ueDtcclxuICAgICAgICBsZXQgY29vclkgPSBjb29yZGluYXRlQXJyYXlbeF1beTJdLnk7XHJcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG5leHRTcXVhcmU7XHJcbiAgICAgICAgY3R4LmZpbGxSZWN0KGNvb3JYLCBjb29yWSwgMjEsIDIxKTtcclxuXHJcbiAgICAgICAgc3F1YXJlID0gMDtcclxuICAgICAgICBnYW1lQm9hcmRBcnJheVt4XVtpXSA9IDA7IC8vIENsZWFyIHRoZSBzcG90IGluIEdCQVxyXG4gICAgICAgIHN0b3BwZWRTaGFwZUFycmF5W3hdW2ldID0gMDsgLy8gQ2xlYXIgdGhlIHNwb3QgaW4gU1NBXHJcbiAgICAgICAgY29vclggPSBjb29yZGluYXRlQXJyYXlbeF1baV0ueDtcclxuICAgICAgICBjb29yWSA9IGNvb3JkaW5hdGVBcnJheVt4XVtpXS55O1xyXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIndoaXRlXCI7XHJcbiAgICAgICAgY3R4LmZpbGxSZWN0KGNvb3JYLCBjb29yWSwgMjEsIDIxKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8gZnVuY3Rpb24gTW92ZVJvd3NEb3duKHJvd3NUb0RlbGV0ZSwgc3RhcnRPZkRlbGV0aW9uKSB7XHJcbi8vICAgZm9yICh2YXIgaSA9IHN0YXJ0T2ZEZWxldGlvbiAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbi8vICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGdhbWVCb2FyZEFycmF5V2lkdGg7IHgrKykge1xyXG4vLyAgICAgICB2YXIgeTIgPSBpICsgcm93c1RvRGVsZXRlO1xyXG4vLyAgICAgICB2YXIgc2hhcGUgPSBzdG9wcGVkU2hhcGVBcnJheVt4XVtpXTtcclxuLy8gICAgICAgdmFyIG5leHRTaGFwZSA9IHN0b3BwZWRTaGFwZUFycmF5W3hdW3kyXTtcclxuLy8gICAgICAgaWYgKHR5cGVvZiBzaGFwZSA9PT0gXCJzdHJpbmdcIikge1xyXG4vLyAgICAgICAgIG5leHRTaGFwZSA9IHNoYXBlO1xyXG4vLyAgICAgICAgIGdhbWVCb2FyZEFycmF5W3hdW3kyXSA9IDE7XHJcbi8vICAgICAgICAgc3RvcHBlZFNoYXBlQXJyYXlbeF1beTJdID0gc2hhcGU7XHJcbi8vICAgICAgICAgbGV0IGNvb3JYID0gY29vcmRpbmF0ZUFycmF5W3hdW3kyXS54O1xyXG4vLyAgICAgICAgIGxldCBjb29yWSA9IGNvb3JkaW5hdGVBcnJheVt4XVt5Ml0ueTtcclxuLy8gICAgICAgICBjdHguZmlsbFN0eWxlID0gbmV4dFNxdWFyZTtcclxuLy8gICAgICAgICBjdHguZmlsbFJlY3QoY29vclgsIGNvb3JZLCAyMCwgMjApO1xyXG4vLyAgICAgICAgIHNoYXBlID0gMDtcclxuLy8gICAgICAgICBnYW1lQm9hcmRBcnJheVt4XVtpXSA9IDA7XHJcbi8vICAgICAgICAgc3RvcHBlZFNoYXBlQXJyYXlbeF1baV0gPSAwO1xyXG4vLyAgICAgICAgIGNvb3JYID0gY29vcmRpbmF0ZUFycmF5W3hdW2ldLng7XHJcbi8vICAgICAgICAgY29vclkgPSBjb29yZGluYXRlQXJyYXlbeF1baV0ueTtcclxuLy8gICAgICAgICBjdHguZmlsbFN0eWxlID0gXCJ3aGl0ZVwiO1xyXG4vLyAgICAgICAgIGN0eC5maWxsUmVjdChjb29yWCwgY29vclksIDIwLCAyMCk7XHJcbi8vICAgICAgIH1cclxuLy8gICAgIH1cclxuLy8gICB9XHJcbi8vIH1cclxuXHJcbmZ1bmN0aW9uIFJvdGF0ZVRldHJvbWlubygpIHtcclxuICBsZXQgbmV3Um90YXRpb24gPSBuZXcgQXJyYXkoKTtcclxuICBsZXQgdGV0cm9taW5vQ29weSA9IGN1cnJlbnRUZXRyb21pbm87XHJcbiAgbGV0IGN1cnJlbnRUZXRyb21pbm9CYWNrVXA7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXRyb21pbm9Db3B5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjdXJyZW50VGV0cm9taW5vQmFja1VwID0gWy4uLmN1cnJlbnRUZXRyb21pbm9dO1xyXG4gICAgbGV0IHggPSB0ZXRyb21pbm9Db3B5W2ldWzBdO1xyXG4gICAgbGV0IHkgPSB0ZXRyb21pbm9Db3B5W2ldWzFdO1xyXG4gICAgbGV0IG5ld1ggPSBHZXRMYXN0U3F1YXJlWCgpIC0geTtcclxuICAgIGxldCBuZXdZID0geDtcclxuICAgIG5ld1JvdGF0aW9uLnB1c2goW25ld1gsIG5ld1ldKTtcclxuICB9XHJcbiAgRGVsZXRlVGV0cm9taW5vKCk7XHJcbiAgdHJ5IHtcclxuICAgIGN1cnJlbnRUZXRyb21pbm8gPSBuZXdSb3RhdGlvbjtcclxuICAgIERyYXdUZXRyb21pbm8oKTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICBpZiAoZSBpbnN0YW5jZW9mIFR5cGVFcnJvcikge1xyXG4gICAgICBjdXJyZW50VGV0cm9taW5vID0gY3VycmVudFRldHJvbWlub0JhY2tVcDtcclxuICAgICAgRGVsZXRlVGV0cm9taW5vKCk7XHJcbiAgICAgIERyYXdUZXRyb21pbm8oKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuZnVuY3Rpb24gR2V0TGFzdFNxdWFyZVgoKSB7XHJcbiAgbGV0IGxhc3RYID0gMDtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbnRUZXRyb21pbm8ubGVuZ3RoOyBpKyspIHtcclxuICAgIGxldCBzcXVhcmUgPSBjdXJyZW50VGV0cm9taW5vW2ldO1xyXG4gICAgaWYgKHNxdWFyZVswXSA+IGxhc3RYKSBsYXN0WCA9IHNxdWFyZVswXTtcclxuICB9XHJcbiAgcmV0dXJuIGxhc3RYO1xyXG59XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n')}]);